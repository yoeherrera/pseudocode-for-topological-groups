\documentclass[preview]{standalone}

\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{lmodern}
\usepackage{listings}
\lstset{escapeinside={(*}{*)},   basicstyle=\ttfamily,
    breaklines=true,
    columns=fixed,
    fontadjust=true,
    basewidth=0.5em
    }  

\begin{document}

\begin{lstlisting}
	(*\bf spec*) ContBinFunc =
	
	(*\bf sorts*) PX, PXX, Sets, TX, TXX, X, XX
	(*\bf sorts*) TX < PX; TXX < PXX; PX, PXX, X, XX < Sets
	
	(*\bf op*) EmpSet : Sets
	(*\bf op*) PX' : Sets
	(*\bf op*) PXX' : Sets
	(*\bf op*) TX' : Sets
	(*\bf op*) TXX' : Sets
	(*\bf op*) Uni__ : Sets (*$\to$*) Sets
	(*\bf op*) X' : Sets
	(*\bf op*) XX' : Sets
	(*\bf op*) __inter__ : Sets (*$\times$*) Sets (*$\to$*) Sets
	(*\bf op*) __ordpair__ : Sets (*$\times$*) Sets (*$\to$*) Sets
	(*\bf op*) __prod__ : Sets (*$\times$*) Sets (*$\to$*) Sets
	(*\bf op*) f : XX (*$\to$*) X
	(*\bf op*) inversef : TX (*$\to$*) TXX
	
	(*\bf pred*) __el__ : Sets (*$\times$*) Sets
	(*\bf pred*) __subset__ : Sets (*$\times$*) Sets
	
	%% Simulation of X, TX and PX
	(*$\forall$*)x : Sets . x (*$\in$*) X (*$\Leftrightarrow$*) x el X' %(Ax1)%
	(*$\forall$*)x : Sets . x (*$\in$*) TX (*$\Leftrightarrow$*) x el TX' %(Ax2)%
	(*$\forall$*)x : Sets . x (*$\in$*) PX (*$\Leftrightarrow$*) x el PX' %(Ax3)%
	
	%% Simulation of XX, TXX, PXX
	(*$\forall$*)x : Sets . x (*$\in$*) XX (*$\Leftrightarrow$*) x el XX' %(Ax1_25)%
	(*$\forall$*)x : Sets . x (*$\in$*) TXX (*$\Leftrightarrow$*) x el TXX' %(Ax2_36)%
	(*$\forall$*)x : Sets . x (*$\in$*) PXX (*$\Leftrightarrow$*) x el PXX' %(Ax3_42)%
	
	
	
	%% Definition of subset
	(*$\forall$*)x, y, z : Sets . x subset y (*$\Leftrightarrow$*) (z el x (*$\Rightarrow$*) z el y) %(Ax7)%
	
	%% Definition of ops
	. TXX' subset PXX' %(Ax11_27)%
	. TX' subset PX' %(Ax12_28)%
	(*$\forall$*)x : Sets . not x el EmpSet %(Ax8)%
	(*$\forall$*)x : Sets . x el PXX' (*$\Leftrightarrow$*) x subset XX' %(Ax9_48)%
	(*$\forall$*)x : Sets . x el PX' (*$\Leftrightarrow$*) x subset X' %(Ax10_26)%
	
	(*$\forall$*)x, y, z : Sets . x el y inter z (*$\Leftrightarrow$*) x el y (*$\wedge$*) x el z %(Ax11)%
	(*$\forall$*)x, y : Sets. x el Uni y (*$\Leftrightarrow$*) (*$\exists$*) z : Sets . z el y (*$\wedge$*) x el z %(Ax12)%
	(*$\forall$*)x, y, z : Sets. z el x ordpair y (*$\Leftrightarrow$*) (*$\forall$*)s : Sets. (s el z (*$\Leftrightarrow$*) s = x) (*$\lor$*) (s el z (*$\Leftrightarrow$*) s = x (*$\lor$*) s = y)%(Ax13)%
	(*$\forall$*)A, B, z : Sets . z el A prod B (*$\Leftrightarrow$*) (*$\exists$*) x, y : Sets . x el A (*$\wedge$*) y el B (*$\wedge$*) z = x ordpair y %(Ax14)%
	
	%% XX, TXX is product
	. XX' = X' prod X' %(Ax23)%
	(*$\forall$*)z : Sets . z el TXX' (*$\Leftrightarrow$*) (*$\exists$*) x, y : TX . z = x prod y %(Ax24)%
	
	
	%% TX is topology
	. EmpSet el TX' %(Ax15)%
	. X' el TX' %(Ax16)%
	(*$\forall$*)x, y : TX . x inter y el TX' %(Ax17)%
	(*$\forall$*)x : Sets . x subset TX' (*$\Rightarrow$*) Uni x el TX' %(Ax18)%
	
	%% TXX is topology.
	. EmpSet el TXX' %(Ax15_31)%
	. XX' el TXX' %(Ax16_32)%
	(*$\forall$*)x, y : TXX . x inter y el TXX' %(Ax17_33)%
	(*$\forall$*)x : Sets . x subset TXX' (*$\Rightarrow$*) Uni x el TXX' %(Ax18_34)%
	
	%% Definition of inversef
	(*$\forall$*)y : TX; x : XX . x el inversef(y) (*$\Leftrightarrow$*) f(x) el y %(Ax23_40)%
	
	%% f is continuous
	(*$\forall$*)y : TX . inversef(y) el TXX' %(Ax24_41)%
	
	end
	
	
	(*\bf spec*) EnrGroup =
	
	(*\bf sorts*)  Sets, X, XX;
	sorts	X < Sets; XX < Sets
	
	ops 	0 : X;
	X', XX' : Sets
	__ ordpair __ : Sets (*$\times$*) Sets (*$\to$*) Sets
	__ prod __ : Sets (*$\times$*) Sets (*$\to$*) Sets
	__ + __ : X (*$\times$*) X (*$\to$*) X
	Addinv : X (*$\to$*) X
	++ : XX (*$\to$*) X
	embedding : X (*$\to$*) Sets %% needed for syntax
	__ Xpair __ : X (*$\times$*) X (*$\to$*) XX %% the problem is + operates on L but ordpair on Sets
	
	(*\bf preds*) __ el __ : Sets (*$\times$*) Sets; %% is the predicate "in" not already implemented (*$\in$*) hets?
	
	%% L' and LS' simulates L and LS
	(*$\forall$*)x : Sets
	. x (*$\in$*) X (*$\Leftrightarrow$*) x el X'
	. x (*$\in$*) XX (*$\Leftrightarrow$*) x el XX'
	
	%% definition of Lpair and embedding NEW
	(*$\forall$*)x : X. x = embedding(x)
	(*$\forall$*)a, b : X . a Xpair b = embedding(a) ordpair embedding(b)
	
	%% Axioms of a Group.
	(*$\forall$*)x, y, z : X. (x + y) + z = x + (y + z)
	(*$\forall$*)x : X. x + 0 = x  right side is theorem left side and other group axioms : let x + 0 = x (*$\forall$*)x (*$\in$*) G (*$\Rightarrow$*) 0 + x = (x + -x) + x = x + (-x + x) = x 
	(*$\forall$*)x : X. Addinv(x) + x = 0  same here : 
	%% x + -x = --x + -x + x + -x = --x + -x = 0
	
	%% Defining ordpair
	(*$\forall$*)x, y, z : Sets. z el x ordpair y (*$\Leftrightarrow$*) (*$\forall$*)s : Sets. (s el z (*$\Leftrightarrow$*) s = x) (*$\lor$*) (s el z (*$\Leftrightarrow$*) s = x (*$\lor$*) s = y)
	
	%% Defining prod
	(*$\forall$*)A, B, z : Sets . z el A prod B (*$\Leftrightarrow$*) (*$\exists$*) x, y : Sets . x el A (*$\wedge$*) y el B (*$\wedge$*) z = x ordpair y 
	
	%% Specifying the fact that LS is the cartesian product of G with G
	. XX' = X' prod X'  
	
	%% ++ simulates +
	(*$\forall$*)a, b : X. a + b = ++(a Xpair b) %% corrected	why not "(*$\forall$*)a, b : L. a + b = ++(a ordpair b)" problem: operations defined on L and Sets. solution: embedding. NEED 2 FIND A BETTER WAY
	
	end
	
	
	(*\bf spec*) Generic = 
	
	sorts	Sets, G, GS
	
	(*\bf ops*) G', GS' : Sets
	__ ordpair __ : Sets (*$\times$*) Sets (*$\to$*) Sets
	__ prod __ : Sets (*$\times$*) Sets (*$\to$*) Sets
	++ : GS (*$\to$*) G
	
	pred	__ el __ : Sets (*$\times$*) Sets
	
	end
	
	
	view I1 : Generic to EnrGroup =
	Sets (*$\mapsto$*) Sets, G (*$\mapsto$*) X, GS (*$\mapsto$*) XX, G' (*$\mapsto$*) X', GS' (*$\mapsto$*) XX', __ el __ (*$\mapsto$*) __ el __, __ ordpair __ (*$\mapsto$*) __ ordpair __, __ prod __ (*$\mapsto$*) __ prod __, ++ (*$\mapsto$*) ++
	end
	
	view I2 : Generic to ContBinFunc =
	Sets (*$\mapsto$*) Sets, G (*$\mapsto$*) X, GS (*$\mapsto$*) XX, G' (*$\mapsto$*) X', GS' (*$\mapsto$*) XX', __ el __ (*$\mapsto$*) __el__, __ ordpair __ (*$\mapsto$*) __ordpair__, __ prod __ (*$\mapsto$*) __prod__, ++ (*$\mapsto$*) f
	end
	
	
	(*\bf spec*) Colimit = combine I1, I2
\end{lstlisting}

\end{document}